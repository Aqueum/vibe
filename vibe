#!/bin/bash
# vibe â€” a thin wrapper around ClaudeBox for per-project YOLO vibe coding sessions
# https://github.com/Aqueum/vibe
#
# Usage:
#   vibe                  # cd to your project folder, then just run this
#   vibe <project-name>   # launch by name from anywhere (uses VIBE_PROJECTS_DIR)
#   vibe --rebuild        # force rebuild of ClaudeBox image
#   vibe --list           # list available projects
#   vibe --help           # show this help

set -euo pipefail

# â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CONFIG_FILE="${VIBE_CONFIG:-$HOME/.vibe/config}"
TOKENS_FILE="$HOME/.vibe/tokens"
SKIPPED_FILE="$HOME/.vibe/skipped"

if [ -f "$CONFIG_FILE" ]; then
  # shellcheck source=/dev/null
  source "$CONFIG_FILE"
fi

PROJECTS_DIR="${VIBE_PROJECTS_DIR:-$HOME/Projects}"

# â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
usage() {
  grep '^#' "$0" | grep -v '#!/' | sed 's/^# \?//'
  exit 0
}

require() {
  if ! command -v "$1" &>/dev/null; then
    echo "  âœ— '$1' not found. $2"
    exit 1
  fi
}

# Portable lowercase â€” avoids ${var,,} which requires bash 4+ (macOS ships bash 3.2)
lowercase() {
  echo "$1" | tr '[:upper:]' '[:lower:]'
}

# Detect paths that would generate an invalid Docker image tag via claudebox.
# Docker allows _ and __ as separators but rejects ___ or longer runs.
# A path like "my - project" sanitises to "my___project" (space-hyphen-space â†’ ___),
# which Docker's reference parser rejects as an invalid tag format.
validate_docker_tag_from_path() {
  local path="$1"
  local sanitized
  # Mirror claudebox: lowercase then replace every non-alphanumeric char with _
  sanitized=$(printf '%s' "$path" | tr '[:upper:]' '[:lower:]' | tr -c 'a-z0-9' '_')
  # Three or more consecutive underscores are rejected by Docker's reference parser
  printf '%s' "$sanitized" | grep -q '___' && return 1
  return 0
}

# Three-way prompt: prints "yes", "no", or "never"
ask_yes_no_never() {
  local prompt="$1"
  local reply reply_lc
  while true; do
    read -rp "  $prompt [Y/n/never]: " reply
    reply="${reply:-y}"
    reply_lc=$(lowercase "$reply")
    case "$reply_lc" in
      y|yes)   echo "yes";   return ;;
      n|no)    echo "no";    return ;;
      never)   echo "never"; return ;;
      *) echo "  Please answer y, n, or never." ;;
    esac
  done
}

ask_yes_no() {
  local prompt="$1" default="${2:-y}"
  local options reply reply_lc
  [ "$default" = "n" ] && options="y/N" || options="Y/n"
  read -rp "  $prompt [$options]: " reply
  reply="${reply:-$default}"
  reply_lc=$(lowercase "$reply")
  [ "$reply_lc" = "y" ]
}

# â”€â”€ Git helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

detect_github_repo() {
  local url
  url=$(git remote get-url origin 2>/dev/null) || return 1
  if [[ "$url" =~ github\.com[:/]([^/]+/[^/.]+)(\.git)?$ ]]; then
    echo "${BASH_REMATCH[1]}"
    return 0
  fi
  return 1
}

is_github_skipped() {
  [ -f "$SKIPPED_FILE" ] || return 1
  grep -qxF "$WORKSPACE" "$SKIPPED_FILE"
}

mark_github_skipped() {
  mkdir -p "$(dirname "$SKIPPED_FILE")"
  echo "$WORKSPACE" >> "$SKIPPED_FILE"
  echo "  âœ“ Got it â€” won't ask about GitHub for this project again."
}

ensure_initial_commit() {
  if ! git rev-parse --git-dir &>/dev/null; then
    echo "  Initialising git repository..."
    git init
  fi
  if ! git rev-parse HEAD &>/dev/null 2>&1; then
    git add -A 2>/dev/null || true
    git commit --allow-empty -m "Initial commit" 2>/dev/null || true
    echo "  âœ“ Initial commit created."
  fi
}

create_github_repo() {
  echo ""
  echo "  No GitHub repo found for this project."
  echo ""

  local answer
  answer=$(ask_yes_no_never "Create a GitHub repo for it?")

  case "$answer" in
    never) mark_github_skipped; return ;;
    no)    echo "  Skipping â€” launching without GitHub."; return ;;
  esac

  local repo_name
  read -rp "  Repo name [$PROJECT_NAME]: " repo_name
  repo_name="${repo_name:-$PROJECT_NAME}"

  local visibility="private"
  ask_yes_no "Make it public?" n && visibility="public"

  local description=""
  read -rp "  Description (optional): " description

  ensure_initial_commit

  local gh_user
  gh_user=$(gh api user --jq '.login' 2>/dev/null) || {
    echo "  âœ— Not logged in to GitHub CLI. Run: gh auth login"
    return
  }

  echo "  Creating $visibility repo $gh_user/$repo_name on GitHub..."

  local create_args=("$repo_name" "--$visibility" "--source=." "--push")
  [ -n "$description" ] && create_args+=("--description=$description")

  if gh repo create "${create_args[@]}"; then
    GITHUB_REPO="$gh_user/$repo_name"
    echo "  âœ“ Repo created: https://github.com/$GITHUB_REPO"
  else
    echo "  âœ— Repo creation failed â€” launching without GitHub."
  fi
}

# â”€â”€ Token helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

lookup_token() {
  local repo="$1"
  [ -f "$TOKENS_FILE" ] || return 0
  grep "^${repo}=" "$TOKENS_FILE" 2>/dev/null | cut -d= -f2 || true
}

save_token() {
  local repo="$1" token="$2"
  mkdir -p "$(dirname "$TOKENS_FILE")"
  touch "$TOKENS_FILE"
  local tmp
  tmp=$(mktemp)
  grep -v "^${repo}=" "$TOKENS_FILE" > "$tmp" || true
  echo "${repo}=${token}" >> "$tmp"
  mv "$tmp" "$TOKENS_FILE"
  chmod 600 "$TOKENS_FILE"
}

setup_token() {
  local repo="$1"
  echo ""
  echo "  No GitHub token found for $repo."
  echo ""
  echo "  I'll open GitHub so you can create a fine-grained token."
  echo "  On that page:"
  echo "    1. Give it a name, e.g.: vibe-$(echo "$repo" | cut -d/ -f2)"
  echo "    2. Set an expiry (90 days is a good default)"
  echo "    3. Under 'Repository access' â†’ 'Only select repositories'"
  echo "       â†’ choose $(echo "$repo" | cut -d/ -f2)"
  echo "    4. Under 'Permissions' enable:"
  echo "         Contents        â†’ Read and write"
  echo "         Metadata        â†’ Read-only  (auto-selected)"
  echo "         Pull requests   â†’ Read and write"
  echo "    5. Click 'Generate token' and copy it"
  echo ""
  read -rp "  Press Enter to open GitHub in your browser (or Ctrl+C to skip)..."
  open "https://github.com/settings/personal-access-tokens/new"
  echo ""
  read -rsp "  Paste your token (input is hidden): " input_token
  echo ""

  if [ -z "$input_token" ]; then
    echo "  No token entered â€” launching without GitHub auth."
    GITHUB_TOKEN=""
    return
  fi

  save_token "$repo" "$input_token"
  echo "  âœ“ Token saved â€” you won't be asked again for this repo."
  GITHUB_TOKEN="$input_token"
}

# â”€â”€ ClaudeBox slot helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Returns true if there's at least one authenticated (but not unauthenticated) slot.
# "Authenticated" has capital A; "Unauthenticated" has lowercase a â€” case-sensitive
# grep correctly distinguishes them.
has_authenticated_slot() {
  claudebox slots 2>/dev/null | grep -q "Authenticated"
}

# Returns true if any slot has an actively running container.
# "Active" has capital A; "Inactive" has lowercase a â€” same trick applies.
has_active_session() {
  claudebox slots 2>/dev/null | grep -q "Active"
}

# Returns true if there's an authenticated slot that isn't currently running.
# This means claudebox can start a new session without creating a new slot.
has_idle_authenticated_slot() {
  claudebox slots 2>/dev/null | grep "Authenticated" | grep -q "Inactive"
}

# Authenticates a slot, reusing an existing unauthenticated one if available
# rather than always creating a new one.
setup_claudebox_slot() {
  echo ""
  echo "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo "  Setting up a Claude container slot."
  echo "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo ""

  # Prefer reusing an existing unauthenticated slot over creating a new one.
  local target_slot
  target_slot=$(claudebox slots 2>/dev/null | grep "Unauthenticated" | awk '{print $1}' | head -1)

  if [ -n "$target_slot" ]; then
    echo "  Reusing existing slot $target_slot."
    echo ""
  else
    echo "  Step 1/2: Creating container slot..."
    claudebox create
    echo ""
    target_slot=$(claudebox slots 2>/dev/null | grep "Unauthenticated" | awk '{print $1}' | tail -1)
    target_slot="${target_slot:-1}"
  fi

  echo "  Authenticate with your Claude Pro/Max account."
  echo ""
  echo "  âš   The browser won't open automatically from inside Docker."
  echo "     When you see the login URL, copy it and paste it into"
  echo "     your browser. After logging in, type 'exit' to return here."
  echo ""
  read -rp "  Press Enter to open slot $target_slot for authentication..."
  echo ""
  claudebox slot "$target_slot" || true   # user authenticates then types exit

  echo ""
  if has_authenticated_slot; then
    echo "  âœ“ Authenticated â€” launching your vibe session now."
    echo ""
  else
    echo "  âš   No authenticated slot found."
    echo "     If you didn't finish, run:  claudebox slot $target_slot"
    echo "     Then run vibe again."
    exit 1
  fi
}

# â”€â”€ Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
REBUILD=false
while [[ "${1:-}" == --* ]]; do
  case "$1" in
    --rebuild) REBUILD=true; shift ;;
    --list)
      echo "Projects in $PROJECTS_DIR:"
      ls "$PROJECTS_DIR"
      exit 0
      ;;
    --help|-h) usage ;;
    *) echo "Unknown flag: $1"; exit 1 ;;
  esac
done

# â”€â”€ Resolve workspace â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [ "$#" -eq 0 ]; then
  WORKSPACE="$(pwd)"
  PROJECT_NAME="$(basename "$WORKSPACE")"
else
  PROJECT_NAME="$1"
  if [ -d "$PROJECT_NAME" ]; then
    WORKSPACE="$(cd "$PROJECT_NAME" && pwd)"
    PROJECT_NAME="$(basename "$WORKSPACE")"
  else
    WORKSPACE="$PROJECTS_DIR/$PROJECT_NAME"
    if [ ! -d "$WORKSPACE" ]; then
      echo "  Error: Project not found: $WORKSPACE"
      echo ""
      echo "  Available projects:"
      ls "$PROJECTS_DIR"
      exit 1
    fi
  fi
fi

# â”€â”€ Checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
require claudebox "Install from: https://github.com/RchGrav/claudebox"

if [ -n "${ANTHROPIC_API_KEY:-}" ]; then
  echo "  âš   ANTHROPIC_API_KEY is set â€” Claude Code will bill against your API credits."
  echo "     Unset it to use your Pro/Max subscription instead."
  echo ""
fi

# â”€â”€ Pre-flight: validate workspace path â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if ! validate_docker_tag_from_path "$WORKSPACE"; then
  # Suggest a cleaner folder name: replace spaces with hyphens, squeeze runs of hyphens
  suggested=$(basename "$WORKSPACE" | tr ' ' '-' | tr -s '-')
  echo ""
  echo "  âœ— Your project path would generate an invalid Docker image name."
  echo ""
  echo "     $WORKSPACE"
  echo ""
  echo "  Docker rejects names with three or more consecutive underscores (___), which"
  echo "  occur when a folder name contains sequences like \" - \" (space-hyphen-space)."
  echo ""
  echo "  Rename the folder to fix this â€” for example:"
  echo "    $(basename "$WORKSPACE")  â†’  $suggested"
  echo ""
  exit 1
fi

# â”€â”€ GitHub setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GITHUB_TOKEN=""
GITHUB_REPO=""
cd "$WORKSPACE"

if is_github_skipped; then
  : # silently skip â€” user said never
elif GITHUB_REPO=$(detect_github_repo); then
  GITHUB_TOKEN=$(lookup_token "$GITHUB_REPO")
  if [ -z "$GITHUB_TOKEN" ]; then
    setup_token "$GITHUB_REPO"
  fi
else
  create_github_repo
  if [ -n "$GITHUB_REPO" ]; then
    setup_token "$GITHUB_REPO"
  fi
fi

# â”€â”€ ClaudeBox slot check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if has_active_session; then
  if ! has_idle_authenticated_slot; then
    # All authenticated slots are busy â€” offer to set up an additional one.
    echo "  â„¹  A Claude session is already running in this project."
    echo ""
    if ask_yes_no "Open a new parallel slot?" y; then
      setup_claudebox_slot
    else
      echo "  Exiting â€” the existing session is still running."
      exit 0
    fi
  fi
  # else: an idle authenticated slot is available â€” claudebox will use it.
elif ! has_authenticated_slot; then
  setup_claudebox_slot
fi

# â”€â”€ Ensure Claude skips approval prompts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Write settings.local.json so Claude Code runs without tool-use approval
# prompts inside the container. This is the reliable mechanism â€” the CLI flag
# --dangerously-skip-permissions passed to claudebox is not always forwarded.
mkdir -p "$WORKSPACE/.claude"
printf '{\n  "dangerouslySkipPermissions": true\n}\n' > "$WORKSPACE/.claude/settings.local.json"

# Keep settings.local.json out of git (it's personal/session config).
if [ -f "$WORKSPACE/.gitignore" ]; then
  if ! grep -qF ".claude/settings.local.json" "$WORKSPACE/.gitignore"; then
    echo ".claude/settings.local.json" >> "$WORKSPACE/.gitignore"
  fi
fi

# â”€â”€ Launch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
echo ""
echo "  ðŸš€ vibe session starting"
echo "     project : $PROJECT_NAME"
echo "     path    : $WORKSPACE"
[ -n "$GITHUB_REPO" ] && echo "     github  : $GITHUB_REPO"
echo ""

CLAUDEBOX_ARGS=(--dangerously-skip-permissions)
[ "$REBUILD" = true ] && CLAUDEBOX_ARGS+=(--rebuild)

if [ -n "$GITHUB_TOKEN" ]; then
  GITHUB_TOKEN="$GITHUB_TOKEN" claudebox "${CLAUDEBOX_ARGS[@]}"
else
  claudebox "${CLAUDEBOX_ARGS[@]}"
fi
